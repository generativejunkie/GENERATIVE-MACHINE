<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>IMAGE MACHINE</title>
  
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <meta name="msapplication-TileColor" content="#000000">
  <meta name="theme-color" content="#000000">
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    body { margin: 0; padding: 0; background-color: #000; color: white; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; overflow: hidden; }
    #canvas-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; cursor: pointer; }
    .ui-layer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; pointer-events: none; }
    .ui-layer > * { pointer-events: auto; }
    #loading-overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background-color: #000; z-index: 10;
      display: flex; align-items: center; justify-content: center;
      color: white; font-size: 1.2rem; transition: opacity 0.5s ease;
    }
    #prompt-text {
        position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%);
        z-index: 3; font-size: 1.5rem; font-weight: 200; letter-spacing: 0.2em;
        color: rgba(255, 255, 255, 0.7); opacity: 0;
        transition: opacity 1s ease-in-out; animation: subtle-pulse 2s infinite;
        pointer-events: none;
    }
    #prompt-text.is-visible { opacity: 1; }
    @keyframes subtle-pulse { 0%, 100% { opacity: 0.7; } 50% { opacity: 0.4; } }
  </style>
</head>
<body>

  <div id="loading-overlay"><p>Loading Machine...</p></div>
  <div id="canvas-container"></div>
  <div id="prompt-text">CLICK / TAP</div>

  <div class="ui-layer flex flex-col justify-between p-4">
    <div>
      <a href="/" class="text-white text-lg hover:opacity-75 transition-opacity">← Back</a>
    </div>
    <footer class="w-full text-center">
      <p style="color: white; font-size: 10px; font-family: Verdana, sans-serif;">©︎GENERATIVE JUNKIE</p>
    </footer>
  </div>

  <script>
    const sketch = (p) => {
      const imageCount = 394;
      const filePrefix = "photos/photo";
      const fileSuffix = ".webp";
      const numberPadding = 3;

      let imageFileNames = [];
      let allImages = []; // 全ての画像をここに格納
      let currentImageIndex = 0;
      let nextImageIndex = 0;
      
      let animationState = 'display';
      let animationFrame = 0;
      let transitionType = 'blocks';
      const chaosDuration = 15;
      const transitionDuration = 40;
      
      let promptTimer = null;
      const promptText = document.getElementById('prompt-text');
      let effectParams = {};

      for (let i = 1; i <= imageCount; i++) {
        imageFileNames.push(`${filePrefix}${i.toString().padStart(numberPadding, '0')}${fileSuffix}`);
      }
      
      // ★変更点：preloadはファイルの読み込みだけに専念させる
      p.preload = () => {
        for (let i = 0; i < imageFileNames.length; i++) {
            allImages.push(p.loadImage(imageFileNames[i]));
        }
      };

      // ★変更点：setupで初期設定をすべて行う
      p.setup = () => {
        const canvasContainer = document.getElementById('canvas-container');
        p.createCanvas(canvasContainer.offsetWidth, canvasContainer.offsetHeight).parent(canvasContainer);
        p.background(0);
        
        // 読み込まれた画像にファイルパスを紐付ける
        for(let i=0; i<allImages.length; i++) {
            allImages[i].filePath = imageFileNames[i];
        }

        const loadingOverlay = document.getElementById('loading-overlay');
        loadingOverlay.style.opacity = '0';
        setTimeout(() => { loadingOverlay.style.display = 'none'; }, 500);

        currentImageIndex = p.floor(p.random(allImages.length));
        animationState = 'display';
        promptTimer = setTimeout(() => promptText.classList.add('is-visible'), 3000);
        
        const userStartAudio = () => { if (p.getAudioContext().state !== 'running') { p.getAudioContext().resume(); } };
        canvasContainer.addEventListener('touchstart', userStartAudio, { once: true });
        canvasContainer.addEventListener('mousedown', userStartAudio, { once: true });
      };

      p.draw = () => {
        const currentImage = allImages[currentImageIndex];
        const nextImage = allImages[nextImageIndex];

        switch (animationState) {
          case 'decay':
            runTransition(currentImage, animationFrame / transitionDuration, true);
            animationFrame++;
            if (animationFrame > transitionDuration) { animationFrame = 0; animationState = 'chaos'; }
            break;
            
          case 'chaos':
            drawGlitch(nextImage);
            animationFrame++;
            if (animationFrame > chaosDuration) {
              animationFrame = 0; animationState = 'rebuild';
              currentImageIndex = nextImageIndex;
            }
            break;

          case 'rebuild':
            runTransition(allImages[currentImageIndex], animationFrame / transitionDuration, false);
            animationFrame++;
            if (animationFrame > transitionDuration) {
              animationFrame = 0; animationState = 'display';
              promptTimer = setTimeout(() => promptText.classList.add('is-visible'), 5000);
            }
            break;
            
          default:
            drawImageFullscreen(currentImage);
            break;
        }
      };

      function runTransition(img, progress, isDecay) { /* ... (変更なし) ... */ }
      function drawBlocks(img, progress, isDecay) { /* ... (変更なし) ... */ }
      function drawSlide(img, progress, isDecay) { /* ... (変更なし) ... */ }
      function drawCircles(img, progress, isDecay) { /* ... (変更なし) ... */ }
      function drawGlitch(nextImg) { /* ... (変更なし) ... */ }
      function drawImageFullscreen(img) { /* ... (変更なし) ... */ }
      
      const handleInteraction = () => {
        if (animationState === 'display' && allImages.length > 1) {
          promptText.classList.remove('is-visible');
          clearTimeout(promptTimer);
          
          const transitionTypes = ['blocks', 'slide', 'circles'];
          transitionType = p.random(transitionTypes);
          
          if (transitionType === 'blocks') { effectParams = { startSize: 5, endSize: p.random(80, 150), density: p.random(0.6, 1.0) }; }
          else if (transitionType === 'slide') { effectParams = { sliceCount: p.random(20, 80), wave: p.random(5, 15), offsetAmount: p.random(20, 80) }; }
          else if (transitionType === 'circles') { effectParams = { circleCount: p.random(100, 400), maxRadius: p.random(100, 500) }; }
          
          let newIndex = p.floor(p.random(allImages.length));
          while (newIndex === currentImageIndex) { newIndex = p.floor(p.random(allImages.length)); }
          nextImageIndex = newIndex;

          animationFrame = 0;
          animationState = 'decay';
        }
      };
      p.mousePressed = handleInteraction;
      p.touchStarted = handleInteraction;

      p.windowResized = () => {
        const canvasContainer = document.getElementById('canvas-container');
        p.resizeCanvas(canvasContainer.offsetWidth, canvasContainer.offsetHeight);
      };
    };

    new p5(sketch);
  </script>

</body>
</html>