@ -40,9 +40,7 @@
<body>

  <div id="loading-overlay"><p>Loading Machine...</p></div>

  <div id="canvas-container"></div>

  <div id="prompt-text">CLICK / TAP</div>

  <div class="ui-layer flex flex-col justify-between p-4">
@ -68,62 +66,28 @@
      let animationState = 'display';
      let animationFrame = 0;
      let transitionType = 'blocks';
      const chaosDuration = 20;
      const transitionDuration = 60;
      const chaosDuration = 15;
      const transitionDuration = 40;
      
      let promptTimer = null;
      const promptText = document.getElementById('prompt-text');
      
      // ★追加: エフェクトのパラメータを保存するオブジェクト
      let effectParams = {};

      for (let i = 1; i <= imageCount; i++) {
        imageFileNames.push(`${filePrefix}${i.toString().padStart(numberPadding, '0')}${fileSuffix}`);
      }
      
      p.preload = () => {
          const initialIndex = p.floor(p.random(imageFileNames.length));
          currentImage = p.loadImage(imageFileNames[initialIndex], 
            (img) => { img.filePath = imageFileNames[initialIndex]; },
            () => { console.error("最初の画像の読み込みに失敗しました。"); }
          );
      };

      p.setup = () => {
        const canvasContainer = document.getElementById('canvas-container');
        p.createCanvas(canvasContainer.offsetWidth, canvasContainer.offsetHeight).parent(canvasContainer);
        p.background(0);
        
        const loadingOverlay = document.getElementById('loading-overlay');
        loadingOverlay.style.opacity = '0';
        setTimeout(() => { loadingOverlay.style.display = 'none'; }, 500);

        if (currentImage && currentImage.width > 0) {
            animationState = 'display';
            promptTimer = setTimeout(() => promptText.classList.add('is-visible'), 3000);
        } else {
            animationState = 'error';
        }
        
        const userStartAudio = () => { if (p.getAudioContext().state !== 'running') { p.getAudioContext().resume(); } };
        canvasContainer.addEventListener('touchstart', userStartAudio, { once: true });
        canvasContainer.addEventListener('mousedown', userStartAudio, { once: true });
      };
      p.preload = () => { /* ... (変更なし) ... */ };
      p.setup = () => { /* ... (変更なし) ... */ };

      p.draw = () => {
        if (animationState === 'error') {
            p.background(0);
            p.fill(255, 0, 0);
            p.textAlign(p.CENTER);
            p.textSize(16);
            p.text("Error: Failed to load the initial image.\nPlease check the file paths in the code.", p.width / 2, p.height / 2);
            p.noLoop();
            return;
        }
        
        if (!currentImage) { p.background(0); return; }

        switch (animationState) {
          case 'decay':
            if(transitionType === 'blocks') drawBlocks(currentImage, animationFrame / transitionDuration, true);
            else drawSlide(currentImage, animationFrame / transitionDuration, true);
            runTransition(currentImage, animationFrame / transitionDuration, true);
            animationFrame++;
            if (animationFrame > transitionDuration) { animationFrame = 0; animationState = 'chaos'; }
            break;
@ -138,8 +102,7 @@
            break;

          case 'rebuild':
            if(transitionType === 'blocks') drawBlocks(currentImage, animationFrame / transitionDuration, false);
            else drawSlide(currentImage, animationFrame / transitionDuration, false);
            runTransition(currentImage, animationFrame / transitionDuration, false);
            animationFrame++;
            if (animationFrame > transitionDuration) {
              animationFrame = 0; animationState = 'display';
@ -153,29 +116,34 @@
        }
      };

      function loadImageDynamically(index, callback) {
        p.loadImage(imageFileNames[index], 
          (img) => {
            img.filePath = imageFileNames[index];
            callback(img);
          },
          () => {
            console.warn(`画像の読み込みに失敗 or 欠番: ${imageFileNames[index]}. 別の画像を試します。`);
            const newIndex = p.floor(p.random(imageFileNames.length));
            loadImageDynamically(newIndex, callback);
          }
        );
      // --- ▼▼▼ エフェクト関連の関数を再編成・追加 ▼▼▼ ---

      function loadImageDynamically(index, callback) { /* ... (変更なし) ... */ }
      function drawImageFullscreen(img) { /* ... (変更なし) ... */ }

      // エフェクトを実行するメインの関数
      function runTransition(img, progress, isDecay) {
        switch(transitionType) {
          case 'blocks':
            drawBlocks(img, progress, isDecay);
            break;
          case 'slide':
            drawSlide(img, progress, isDecay);
            break;
          case 'circles':
            drawCircles(img, progress, isDecay);
            break;
        }
      }
      

      function drawBlocks(img, progress, isDecay) {
        p.background(0);
        const blockSize = p.map(p.constrain(progress, 0, 1), 0, 1, isDecay ? 5 : 100, isDecay ? 100 : 5);
        const blockSize = isDecay ? p.map(progress, 0, 1, effectParams.startSize, effectParams.endSize) : p.map(progress, 0, 1, effectParams.endSize, effectParams.startSize);
        for (let y = 0; y < p.height; y += blockSize) {
          for (let x = 0; x < p.width; x += blockSize) {
            if (p.random() < 0.8) {
            if (p.random() < effectParams.density) {
              let c = img.get(x, y);
              p.fill(c);
              p.noStroke();
              p.fill(c); p.noStroke();
              p.rect(x, y, blockSize, blockSize);
            }
          }
@ -184,69 +152,79 @@

      function drawSlide(img, progress, isDecay) {
        p.background(0);
        const sliceCount = 50;
        const sliceHeight = p.height / sliceCount;
        for (let i = 0; i < sliceCount; i++) {
        const sliceHeight = p.height / effectParams.sliceCount;
        for (let i = 0; i < effectParams.sliceCount; i++) {
          let y = i * sliceHeight;
          let offset = p.sin(i * 10 + p.frameCount * 2) * 50;
          let offset = p.sin(i * effectParams.wave + p.frameCount * 2) * effectParams.offsetAmount;
          let currentProgress = isDecay ? progress : 1.0 - progress;
          let slideAmount = p.map(currentProgress, 0, 1, 0, p.width * 1.5);
          let sx = 0;
          let dx = p.random(-slideAmount, slideAmount) + offset;
          p.copy(img, sx, y, img.width, sliceHeight, dx, y, p.width, sliceHeight);
          p.copy(img, 0, y, img.width, sliceHeight, p.random(-slideAmount, slideAmount) + offset, y, p.width, sliceHeight);
        }
      }
      

      // ★追加: 新しい円形エフェクト
      function drawCircles(img, progress, isDecay) {
        p.background(0);
        let currentProgress = isDecay ? progress : 1.0 - progress;
        for(let i=0; i < effectParams.circleCount; i++) {
          let x = p.random(p.width);
          let y = p.random(p.height);
          let c = img.get(x,y);
          p.fill(c, p.random(100, 255));
          p.noStroke();
          let radius = p.map(currentProgress, 0, 1, 0, effectParams.maxRadius) * p.noise(x,y,p.frameCount);
          p.ellipse(x, y, radius, radius);
        }
      }

      function drawGlitch() {
        for (let i = 0; i < p.random(30, 80); i++) {
        for (let i = 0; i < p.random(30, 120); i++) {
          let x = p.random(p.width); let y = p.random(p.height);
          let w = p.random(10, p.width * 0.8); let h = p.random(2, 20);
          let w = p.random(5, p.width * 0.9); let h = p.random(1, 15);
          if (nextImage) {
              let c = nextImage.get(x, y);
              p.fill(p.red(c) + p.random(-50, 50), p.green(c), p.blue(c) + p.random(-50, 50));
              p.fill(p.red(c) + p.random(-100, 100), p.green(c) + p.random(-20, 20), p.blue(c) + p.random(-100, 100));
          }
          p.noStroke(); p.rect(x, y, w, h);
        }
      }
      
      function drawImageFullscreen(img) {
          p.imageMode(p.CENTER);
          const canvasRatio = p.width / p.height;
          const imageRatio = img.width / img.height;
          if (canvasRatio > imageRatio) {
              p.image(img, p.width / 2, p.height / 2, p.width, p.width / imageRatio);
          } else {
              p.image(img, p.width / 2, p.height / 2, p.height * imageRatio, p.height);
          }
      }
      
      const handleInteraction = () => {
        if (animationState === 'display' && !nextImage && imageFileNames.length > 1) {
          promptText.classList.remove('is-visible');
          clearTimeout(promptTimer);
          transitionType = p.random() > 0.5 ? 'blocks' : 'slide';
          
          // ★変更点: エフェクトタイプをランダムに選び、パラメータも設定
          const transitionTypes = ['blocks', 'slide', 'circles'];
          transitionType = p.random(transitionTypes);
          
          if (transitionType === 'blocks') {
            effectParams = { startSize: 5, endSize: p.random(80, 150), density: p.random(0.6, 1.0) };
          } else if (transitionType === 'slide') {
            effectParams = { sliceCount: p.random(20, 80), wave: p.random(5, 15), offsetAmount: p.random(20, 80) };
          } else if (transitionType === 'circles') {
            effectParams = { circleCount: p.random(100, 400), maxRadius: p.random(100, 500) };
          }
          
          const currentIndex = imageFileNames.indexOf(currentImage.filePath);
          let newIndex = p.floor(p.random(imageFileNames.length));
          while (newIndex === currentIndex) { newIndex = p.floor(p.random(imageFileNames.length)); }
          
          const loadingOverlay = document.getElementById('loading-overlay');
          loadingOverlay.classList.add('is-active'); // 次の画像の読み込み中にローディング表示
          loadingOverlay.classList.add('is-active');
          
          loadImageDynamically(newIndex, (img) => {
            nextImage = img;
            animationFrame = 0;
            animationState = 'decay';
            loadingOverlay.classList.remove('is-active'); // 読み込み完了で非表示
            loadingOverlay.classList.remove('is-active');
          });
        }
      };
      p.mousePressed = handleInteraction;
      p.touchStarted = handleInteraction;

      p.windowResized = () => {
        const canvasContainer = document.getElementById('canvas-container');
        p.resizeCanvas(canvasContainer.offsetWidth, canvasContainer.offsetHeight);
      };
      p.windowResized = () => { /* ... (変更なし) ... */ };
    };

    new p5(sketch);
