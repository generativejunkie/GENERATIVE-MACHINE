<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>IMAGE MACHINE</title>
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <meta name="msapplication-TileColor" content="#000000">
  <meta name="theme-color" content="#000000">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { margin: 0; padding: 0; background-color: #000; color: white; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; overflow: hidden; }
    #canvas-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; cursor: pointer; }
    .ui-layer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; pointer-events: none; }
    .ui-layer > * { pointer-events: auto; }
  </style>
</head>
<body>

  <div id="canvas-container"></div>

  <div class="ui-layer flex flex-col justify-between p-4">
    <div>
      <a href="/" class="text-white text-lg hover:opacity-75 transition-opacity">← Back</a>
    </div>
    <footer class="w-full text-center">
      <p style="color: white; font-size: 10px; font-family: Verdana, sans-serif;">©︎GENERATIVE JUNKIE</p>
    </footer>
  </div>

  <script>
    // --- p5.js スクリプト ---
    const sketch = (p) => {
      // --- ▼▼▼ 設定項目 ▼▼▼ ---
      // photosフォルダにある、あなたの画像ファイル名をすべてここにリストアップしてください
      const imageFileNames = [
        "photos/photo001.webp",
        // "photos/image02.jpg",
        // "photos/image03.png",
        // ... 必要なだけ追加 ...
      ];
      // --- ▲▲▲ 設定ここまで ▲▲▲ ---

      let images = [];
      let currentImageIndex = 0;
      let nextImageIndex = 0;
      
      let animationState = 'display'; // 'decay', 'chaos', 'rebuild', 'display'
      let animationFrame = 0;
      const chaosDuration = 30; // カオス状態のフレーム数
      const transitionDuration = 60; // 崩壊と再構築のアニメーションのフレーム数

      // 画像の先行読み込み
      p.preload = () => {
        for (let i = 0; i < imageFileNames.length; i++) {
          images[i] = p.loadImage(imageFileNames[i]);
        }
      };

      p.setup = () => {
        const canvasContainer = document.getElementById('canvas-container');
        p.createCanvas(canvasContainer.offsetWidth, canvasContainer.offsetHeight).parent(canvasContainer);
        p.background(0);
        // 最初の画像をランダムに選ぶ
        currentImageIndex = p.floor(p.random(images.length));
      };

      p.draw = () => {
        switch (animationState) {
          case 'decay':
            drawImageWithBlocks(images[currentImageIndex], animationFrame / transitionDuration, true);
            animationFrame++;
            if (animationFrame > transitionDuration) {
              animationFrame = 0;
              animationState = 'chaos';
            }
            break;
            
          case 'chaos':
            drawGlitch();
            animationFrame++;
            if (animationFrame > chaosDuration) {
              animationFrame = 0;
              animationState = 'rebuild';
              currentImageIndex = nextImageIndex; // 表示する画像を次のものに更新
            }
            break;

          case 'rebuild':
            drawImageWithBlocks(images[currentImageIndex], animationFrame / transitionDuration, false);
            animationFrame++;
            if (animationFrame > transitionDuration) {
              animationFrame = 0;
              animationState = 'display';
            }
            break;
            
          case 'display':
          default:
            drawImageFullscreen(images[currentImageIndex]);
            break;
        }
      };
      
      // 画像をブロック状に描画する関数 (progress: 0.0 -> 1.0)
      function drawImageWithBlocks(img, progress, isDecay) {
        p.background(0);
        const blockSize = p.map(progress, 0, 1, 100, 5); // ブロックサイズが変化
        const alpha = p.map(progress, 0, 1, 255, 50);

        for (let y = 0; y < p.height; y += blockSize) {
          for (let x = 0; x < p.width; x += blockSize) {
            let probability = isDecay ? progress : (1 - progress);
            if (p.random() < probability) {
              let c = img.get(x, y);
              p.fill(c, alpha);
              p.noStroke();
              p.rect(x, y, blockSize, blockSize);
            }
          }
        }
      }
      
      // 画面全体にグリッチを描画する関数
      function drawGlitch() {
        for (let i = 0; i < 50; i++) {
          let x = p.random(p.width);
          let y = p.random(p.height);
          let w = p.random(20, 200);
          let h = p.random(5, 30);
          let c = images[nextImageIndex].get(x, y); // 次の画像の色を少し使う
          p.fill(c);
          p.noStroke();
          p.rect(x, y, w, h);
        }
      }
      
      // 画像を全画面表示する関数
      function drawImageFullscreen(img) {
          p.imageMode(p.CENTER);
          const canvasRatio = p.width / p.height;
          const imageRatio = img.width / img.height;
          if (canvasRatio > imageRatio) {
              p.image(img, p.width / 2, p.height / 2, p.width, p.width / imageRatio);
          } else {
              p.image(img, p.width / 2, p.height / 2, p.height * imageRatio, p.height);
          }
      }

      // クリックでアニメーションを開始
      p.mousePressed = () => {
        if (animationState === 'display' && images.length > 1) {
          // 次の画像をランダムに選ぶ（現在と被らないように）
          let newIndex = p.floor(p.random(images.length));
          while (newIndex === currentImageIndex) {
            newIndex = p.floor(p.random(images.length));
          }
          nextImageIndex = newIndex;
          
          animationFrame = 0;
          animationState = 'decay';
        }
      };

      p.windowResized = () => {
        const canvasContainer = document.getElementById('canvas-container');
        p.resizeCanvas(canvasContainer.offsetWidth, canvasContainer.offsetHeight);
      };
    };

    new p5(sketch);
  </script>

</body>
</html>