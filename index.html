<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>IMAGE MACHINE</title>
  
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <meta name="msapplication-TileColor" content="#000000">
  <meta name="theme-color" content="#000000">
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    body, a, button {
      cursor: none;
    }
    body { 
      margin: 0; padding: 0; background-color: #000; color: #e0e0e0; 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; 
      overflow: hidden; 
    }
    #canvas-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; cursor: none; }
    .ui-layer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; pointer-events: none; }
    .ui-layer > * { pointer-events: auto; }

    /* ===== ミニマル配色化 ===== */
    a { color: #fff; }
    a:hover { opacity: 0.7; transition: opacity 0.3s ease; }
    .text-shadow { text-shadow: 0 0 8px rgba(255,255,255,0.1); }

    #loading-overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background-color: #000; z-index: 10;
      display: flex; align-items: center; justify-content: center;
      color: #ccc; font-size: 1.2rem; transition: opacity 0.5s ease;
    }
    #prompt-text {
        position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%);
        z-index: 3; font-size: 1.5rem; font-weight: 200; letter-spacing: 0.2em;
        color: rgba(255, 255, 255, 0.6); opacity: 0;
        transition: opacity 1s ease-in-out; animation: subtle-pulse 2s infinite;
        pointer-events: none; text-shadow: 0 0 5px rgba(255,255,255,0.1);
    }
    #prompt-text.is-visible { opacity: 1; }
    @keyframes subtle-pulse { 0%, 100% { opacity: 0.7; } 50% { opacity: 0.4; } }

    /* ===== アイコンカラー: 白黒グレー基調 ===== */
    svg, img.icon, .icon {
      filter: grayscale(100%) brightness(1.2);
    }

    #custom-cursor {
      position: fixed;
      width: 24px;
      height: 24px;
      background-color: transparent;
      border: 1px solid #FFFFFF;
      border-radius: 50%;
      z-index: 9999;
      pointer-events: none;
      transform: translate(-50%, -50%);
      transition: transform 0.2s ease-out, background-color 0.2s ease-out, border-color 0.2s ease-out;
      mix-blend-mode: difference;
    }
    #custom-cursor.cursor-hover {
      background-color: #FFFFFF;
      border-color: transparent;
      transform: translate(-50%, -50%) scale(0.6);
    }
    @media (pointer: coarse) {
      #custom-cursor { display: none; }
      body, a, button, #canvas-container { cursor: auto; }
    }
  </style>
</head>
<body>

  <div id="custom-cursor"></div>

  <div id="loading-overlay"><p>Loading Machine...</p></div>
  <div id="canvas-container"></div>
  <div id="prompt-text">CLICK / TAP</div>

  <div class="ui-layer flex flex-col justify-between p-4">
    <div>
      <a href="/" class="text-white text-lg hover:opacity-75 transition-opacity text-shadow">← Back</a>
    </div>

    <!-- ↓ フッターロゴ削除済み -->
    <!-- <footer class="w-full text-center">
      <p class="text-white text-shadow" style="font-size: 10px; font-family: Verdana, sans-serif;">©︎GENERATIVE JUNKIE</p>
    </footer> -->
  </div>

  <script>
    /* オリジナルのスクリプトは変更なし */
    const sketch = (p) => {
      const imageCount = 394;
      const filePrefix = "photos/photo";
      const fileSuffix = ".webp";
      const numberPadding = 3;

      let imageFileNames = [];
      let allImages = {};
      let currentImageKey = null;
      let nextImageKey = null;
      
      let animationState = 'loading';
      let animationFrame = 0;
      let transitionType = 'blocks';
      const chaosDuration = 15;
      const transitionDuration = 40;
      
      let promptTimer = null;
      const promptText = document.getElementById('prompt-text');
      
      for (let i = 1; i <= imageCount; i++) {
        imageFileNames.push(`${filePrefix}${i.toString().padStart(numberPadding, '0')}${fileSuffix}`);
      }
      
      p.setup = () => {
        const canvasContainer = document.getElementById('canvas-container');
        p.createCanvas(canvasContainer.offsetWidth, canvasContainer.offsetHeight).parent(canvasContainer);
        p.background(0);
        
        const initialIndex = p.floor(p.random(imageFileNames.length));
        loadImageDynamically(imageFileNames[initialIndex], (img) => {
          currentImageKey = img.filePath;
          animationState = 'display';
          const loadingOverlay = document.getElementById('loading-overlay');
          loadingOverlay.style.opacity = '0';
          setTimeout(() => { loadingOverlay.style.display = 'none'; }, 500);
          promptTimer = setTimeout(() => promptText.classList.add('is-visible'), 3000);
        });

        const cursor = document.getElementById('custom-cursor');
        const interactiveElements = document.querySelectorAll('a, #canvas-container');
        window.addEventListener('mousemove', (e) => {
          cursor.style.left = `${e.clientX}px`;
          cursor.style.top = `${e.clientY}px`;
        });
        interactiveElements.forEach(el => {
          el.addEventListener('mouseover', () => { cursor.classList.add('cursor-hover'); });
          el.addEventListener('mouseout', () => { cursor.classList.remove('cursor-hover'); });
        });
      };

      p.draw = () => {
        if (!currentImageKey || !allImages[currentImageKey]) { p.background(0); return; }

        const currentImage = allImages[currentImageKey];
        const nextImage = allImages[nextImageKey];

        switch (animationState) {
          case 'decay':
            runTransition(currentImage, animationFrame / transitionDuration, true);
            animationFrame++;
            if (animationFrame > transitionDuration) { animationFrame = 0; animationState = 'chaos'; }
            break;
            
          case 'chaos':
            drawGlitch(nextImage);
            animationFrame++;
            if (animationFrame > chaosDuration) {
              animationFrame = 0; animationState = 'rebuild';
              currentImageKey = nextImageKey; nextImageKey = null;
            }
            break;

          case 'rebuild':
            runTransition(allImages[currentImageKey], animationFrame / transitionDuration, false);
            animationFrame++;
            if (animationFrame > transitionDuration) {
              animationFrame = 0; animationState = 'display';
              promptTimer = setTimeout(() => promptText.classList.add('is-visible'), 5000);
            }
            break;
            
          default:
            drawImageFullscreen(currentImage);
            break;
        }
      };

      function loadImageDynamically(filePath, callback) {
        if (allImages[filePath]) {
            callback(allImages[filePath]);
            return;
        }
        const loadingOverlay = document.getElementById('loading-overlay');
        if (loadingOverlay) loadingOverlay.classList.add('is-active');

        p.loadImage(filePath, 
          (img) => {
            img.filePath = filePath;
            allImages[filePath] = img;
            callback(img);
            if(loadingOverlay) loadingOverlay.classList.remove('is-active');
          },
          () => {
            console.warn(`Failed to load: ${filePath}. Retrying.`);
            const newIndex = p.floor(p.random(imageFileNames.length));
            loadImageDynamically(imageFileNames[newIndex], callback);
          }
        );
      }
      
      function runTransition(img, progress, isDecay) {
        switch(transitionType) {
          case 'blocks':
            drawBlocks(img, progress, isDecay);
            break;
          case 'slide':
            drawSlide(img, progress, isDecay);
            break;
        }
      }

      function drawBlocks(img, progress, isDecay) {
        p.background(0);
        const blockSize = isDecay ? p.map(progress, 0, 1, 5, 100) : p.map(progress, 0, 1, 100, 5);
        for (let y = 0; y < p.height; y += blockSize) {
          for (let x = 0; x < p.width; x += blockSize) {
            let probability = isDecay ? progress : (1.0 - progress);
            if (p.random() < probability) {
              let c = img.get(x, y);
              p.fill(c);
              p.noStroke();
              p.rect(x, y, blockSize, blockSize);
            }
          }
        }
      }

      function drawSlide(img, progress, isDecay) {
        p.background(0);
        const sliceCount = 80;
        const sliceHeight = p.height / sliceCount;
        for (let i = 0; i < sliceCount; i++) {
          let y = i * sliceHeight;
          let currentProgress = isDecay ? progress : 1.0 - progress;
          let slideAmount = p.map(currentProgress, 0, 1, 0, p.width) * p.noise(i * 0.1, p.frameCount * 0.01);
          let sx = 0;
          let dx = p.random(-slideAmount, slideAmount);
          p.copy(img, sx, y, img.width, sliceHeight, dx, y, p.width, sliceHeight);
        }
      }

      function drawGlitch(nextImg) {
        if (!nextImg) {
          p.background(0);
          return;
        }
        drawImageFullscreen(nextImg);
        for (let i = 0; i < 20; i++) {
            let x = p.random(p.width);
            let y = p.random(p.height);
            let w = p.random(p.width * 0.1, p.width * 0.8);
            let h = p.random(1, p.height * 0.05);
            let grabX = p.random(p.width);
            let grabY = p.random(p.height);
            p.copy(nextImg, grabX, grabY, w, h, x, y, w, h);
        }
      }
      
      function drawImageFullscreen(img) {
          p.imageMode(p.CENTER);
          const canvasRatio = p.width / p.height;
          const imageRatio = img.width / img.height;
          if (canvasRatio > imageRatio) {
              p.image(img, p.width / 2, p.height / 2, p.width, p.width / imageRatio);
          } else {
              p.image(img, p.width / 2, p.height / 2, p.height * imageRatio, p.height);
          }
      }
      
      const handleInteraction = () => {
        if (animationState === 'display' && !nextImageKey && imageFileNames.length > 1) {
          promptText.classList.remove('is-visible');
          clearTimeout(promptTimer);
          
          transitionType = p.random(['blocks', 'slide']);
          
          let newIndex = p.floor(p.random(imageFileNames.length));
          while (imageFileNames[newIndex] === currentImageKey) { 
            newIndex = p.floor(p.random(imageFileNames.length));
          }
          
          loadImageDynamically(imageFileNames[newIndex], (img) => {
            nextImageKey = img.filePath;
            animationFrame = 0;
            animationState = 'decay';
          });
        }
      };
      p.mousePressed = handleInteraction;
      p.touchStarted = handleInteraction;

      p.windowResized = () => {
        const canvasContainer = document.getElementById('canvas-container');
        p.resizeCanvas(canvasContainer.offsetWidth, canvasContainer.offsetHeight);
      };
    };

    new p5(sketch);
  </script>

</body>
</html>
