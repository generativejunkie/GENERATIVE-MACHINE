{"version":3,"file":"index-D5XI3Yma.js","sources":["../../node_modules/@thi.ng/errors/deferror.js","../../node_modules/@thi.ng/errors/illegal-arguments.js","../../node_modules/@thi.ng/errors/illegal-state.js","../../node_modules/@thi.ng/bitstream/input.js","../../node_modules/qoa-format/lib/common.js","../../node_modules/qoa-format/decode.js","../../node_modules/qoa-format/encode.js"],"sourcesContent":["const defError = (prefix, suffix = (msg) => msg !== void 0 ? \": \" + msg : \"\") => class extends Error {\n  origMessage;\n  constructor(msg) {\n    super(prefix(msg) + suffix(msg));\n    this.origMessage = msg !== void 0 ? String(msg) : \"\";\n  }\n};\nexport {\n  defError\n};\n","import { defError } from \"./deferror.js\";\nconst IllegalArgumentError = defError(() => \"illegal argument(s)\");\nconst illegalArgs = (msg) => {\n  throw new IllegalArgumentError(msg);\n};\nexport {\n  IllegalArgumentError,\n  illegalArgs\n};\n","import { defError } from \"./deferror.js\";\nconst IllegalStateError = defError(() => \"illegal state\");\nconst illegalState = (msg) => {\n  throw new IllegalStateError(msg);\n};\nexport {\n  IllegalStateError,\n  illegalState\n};\n","import { illegalArgs } from \"@thi.ng/errors/illegal-arguments\";\nimport { illegalState } from \"@thi.ng/errors/illegal-state\";\nconst U32 = 4294967296;\nclass BitInputStream {\n  buffer;\n  start;\n  limit;\n  pos;\n  bitPos;\n  bit;\n  constructor(buffer, offset = 0, limit = buffer.length << 3) {\n    this.buffer = buffer;\n    this.start = offset;\n    this.limit = limit;\n    this.seek(offset);\n  }\n  *[Symbol.iterator]() {\n    let j = this.start;\n    let i = j >>> 3;\n    let b = 7 - (j & 7);\n    while (j < this.limit) {\n      yield this.buffer[i] >>> b & 1;\n      if (--b < 0) {\n        i++;\n        b = 7;\n      }\n      j++;\n    }\n  }\n  get length() {\n    return this.limit;\n  }\n  get position() {\n    return this.bitPos;\n  }\n  seek(pos) {\n    if (pos < this.start || pos >= this.limit) {\n      illegalArgs(`seek pos out of bounds: ${pos}`);\n    }\n    this.pos = pos >>> 3;\n    this.bit = 8 - (pos & 7);\n    this.bitPos = pos;\n    return this;\n  }\n  read(wordSize = 1, safe = true) {\n    if (wordSize > 32) {\n      return this.read(wordSize - 32, safe) * U32 + this.read(32, safe);\n    } else if (wordSize > 8) {\n      let out = 0;\n      let n = wordSize & -8;\n      let msb = wordSize - n;\n      if (msb > 0) {\n        out = this._read(msb, safe);\n      }\n      while (n > 0) {\n        out = (out << 8 | this._read(8, safe)) >>> 0;\n        n -= 8;\n      }\n      return out;\n    } else {\n      return this._read(wordSize, safe);\n    }\n  }\n  readFields(fields, safe = true) {\n    return fields.map((word) => this.read(word, safe));\n  }\n  readWords(n, wordSize = 8, safe = true) {\n    let out = [];\n    while (n-- > 0) {\n      out.push(this.read(wordSize, safe));\n    }\n    return out;\n  }\n  readStruct(fields, safe = true) {\n    return fields.reduce((acc, [id, word]) => {\n      return acc[id] = this.read(word, safe), acc;\n    }, {});\n  }\n  readBit(safe = true) {\n    safe && this.checkLimit(1);\n    this.bit--;\n    this.bitPos++;\n    let out = this.buffer[this.pos] >>> this.bit & 1;\n    if (this.bit === 0) {\n      this.pos++;\n      this.bit = 8;\n    }\n    return out;\n  }\n  _read(wordSize, safe = true) {\n    safe && this.checkLimit(wordSize);\n    let l = this.bit - wordSize, out;\n    if (l >= 0) {\n      this.bit = l;\n      out = this.buffer[this.pos] >>> l & (1 << wordSize) - 1;\n      if (l === 0) {\n        this.pos++;\n        this.bit = 8;\n      }\n    } else {\n      out = (this.buffer[this.pos++] & (1 << this.bit) - 1) << -l;\n      this.bit = 8 + l;\n      out = out | this.buffer[this.pos] >>> this.bit;\n    }\n    this.bitPos += wordSize;\n    return out;\n  }\n  checkLimit(requested) {\n    if (this.bitPos + requested > this.limit) {\n      illegalState(`can't read past EOF`);\n    }\n  }\n}\nexport {\n  BitInputStream\n};\n","export const QOA_MIN_FILESIZE = 16;\nexport const QOA_MAX_CHANNELS = 8;\n\nexport const QOA_SLICE_LEN = 20;\nexport const QOA_SLICES_PER_FRAME = 256;\nexport const QOA_FRAME_LEN = QOA_SLICES_PER_FRAME * QOA_SLICE_LEN;\nexport const QOA_LMS_LEN = 4;\nexport const QOA_MAGIC = 0x716f6166; /* 'qoaf' */\nexport const QOA_FRAME_SIZE = (channels, slices) =>\n  Math.floor(8 + QOA_LMS_LEN * 4 * channels + 8 * slices * channels);\n\nexport function qoa_clamp(v, min, max) {\n  return v < min ? min : v > max ? max : v;\n}\n\nexport function LMS(h, w) {\n  const history = new Int16Array(h || 4);\n  const weights = new Int16Array(w || 4);\n  return { history, weights };\n}\n\nexport function qoa_lms_predict(weights, history) {\n  return (\n    (weights[0] * history[0] +\n      weights[1] * history[1] +\n      weights[2] * history[2] +\n      weights[3] * history[3]) >>\n    13\n  );\n}\n\nexport function qoa_lms_update(weights, history, sample, residual) {\n  let delta = residual >> 4;\n  weights[0] += history[0] < 0 ? -delta : delta;\n  weights[1] += history[1] < 0 ? -delta : delta;\n  weights[2] += history[2] < 0 ? -delta : delta;\n  weights[3] += history[3] < 0 ? -delta : delta;\n  history[0] = history[1];\n  history[1] = history[2];\n  history[2] = history[3];\n  history[3] = sample;\n}\n\nexport const qoa_round = (num) => Math.sign(num) * Math.round(Math.abs(num));\n\n/* We have 16 different scalefactors. Like the quantized residuals these become\nless accurate at the higher end. In theory, the highest scalefactor that we\nwould need to encode the highest 16bit residual is (2**16)/8 = 8192. However we\nrely on the LMS filter to predict samples accurately enough that a maximum \nresidual of one quarter of the 16 bit range is high sufficent. I.e. with the \nscalefactor 2048 times the quant range of 8 we can encode residuals up to 2**14.\n\nThe scalefactor values are computed as:\nscalefactor_tab[s] <- round(pow(s + 1, 2.75)) */\n\nexport const qoa_scalefactor_tab = Array(16)\n  .fill()\n  .map((_, s) => qoa_round(Math.pow(s + 1, 2.75)));\n\n/* The dequant_tab maps each of the scalefactors and quantized residuals to \ntheir unscaled & dequantized version.\n\nSince qoa_div rounds away from the zero, the smallest entries are mapped to 3/4\ninstead of 1. The dequant_tab assumes the following dequantized values for each \nof the quant_tab indices and is computed as:\nfloat dqt[8] = {0.75, -0.75, 2.5, -2.5, 4.5, -4.5, 7, -7};\ndequant_tab[s][q] <- round(scalefactor_tab[s] * dqt[q]) */\n\nconst dqt = [0.75, -0.75, 2.5, -2.5, 4.5, -4.5, 7, -7];\nexport const qoa_dequant_tab = qoa_scalefactor_tab.map((sf) => {\n  return dqt.map((dq) => qoa_round(dq * sf));\n});\n","import { BitInputStream } from \"@thi.ng/bitstream\";\nimport {\n  qoa_lms_predict,\n  qoa_lms_update,\n  qoa_clamp,\n  qoa_dequant_tab,\n  LMS,\n  QOA_MIN_FILESIZE,\n  QOA_SLICE_LEN,\n  QOA_MAGIC,\n  QOA_LMS_LEN,\n} from \"./lib/common.js\";\n\nfunction decodeHeader(stream) {\n  const magic = stream.read(32);\n  if (magic !== QOA_MAGIC) {\n    throw new Error(`Not a QOA file; expected magic number 'qoaf'`);\n  }\n\n  // peek first frame to get audio file data\n  const header = {\n    samples: stream.read(32),\n    channels: stream.read(8),\n    sampleRate: stream.read(24),\n  };\n\n  // go back to end of header\n  stream.seek(64);\n\n  // return data\n  return header;\n}\n\nfunction qoa_decode_frame(stream, audio, lmses, channelData, sampleOffset) {\n  const channels = stream.read(8);\n  const sampleRate = stream.read(24);\n  const samples = stream.read(16); // frame samples\n  const frameSize = stream.read(16);\n\n  const dataSize = Math.floor(frameSize - 8 - QOA_LMS_LEN * 4 * channels);\n  const numSlices = Math.floor(dataSize / 8);\n  const maxTotalSamples = numSlices * QOA_SLICE_LEN;\n\n  if (\n    channels != audio.channels ||\n    sampleRate != audio.sampleRate ||\n    samples * channels > maxTotalSamples\n  ) {\n    throw new Error(`invalid frame header data`);\n  }\n\n  // decode LMS history and weights\n  for (let c = 0; c < channels; c++) {\n    const lms = lmses[c];\n    for (let i = 0; i < QOA_LMS_LEN; i++) {\n      let h = stream.read(16);\n      lms.history[i] = h;\n    }\n    for (let i = 0; i < QOA_LMS_LEN; i++) {\n      let w = stream.read(16);\n      lms.weights[i] = w;\n    }\n  }\n\n  for (\n    let sample_index = 0;\n    sample_index < samples;\n    sample_index += QOA_SLICE_LEN\n  ) {\n    for (let c = 0; c < channels; c++) {\n      const scalefactor = stream.read(4);\n      const table = qoa_dequant_tab[scalefactor];\n      const slice_start = sample_index;\n      const slice_end = Math.min(sample_index + QOA_SLICE_LEN, samples);\n      const slice_count = slice_end - slice_start;\n      const lms = lmses[c];\n      const sampleData = channelData[c];\n      let idx = sampleOffset + slice_start;\n      const weights = lms.weights;\n      const history = lms.history;\n      let bitsRemaining = 60;\n      // note: this loop is a hot code path and could be optimized\n      for (let i = 0; i < slice_count; i++) {\n        const predicted = qoa_lms_predict(weights, history);\n        const quantized = stream.read(3);\n        const dequantized = table[quantized];\n        const reconstructed = qoa_clamp(predicted + dequantized, -32768, 32767);\n        const sample =\n          reconstructed < 0 ? reconstructed / 32768 : reconstructed / 32767;\n        sampleData[idx++] = sample;\n        qoa_lms_update(weights, history, reconstructed, dequantized);\n        bitsRemaining -= 3;\n      }\n      // skip stream if needed\n      if (bitsRemaining > 0) {\n        stream.read(bitsRemaining);\n      }\n    }\n  }\n\n  return samples;\n}\n\nexport default function decode(data) {\n  if (data.byteLength < QOA_MIN_FILESIZE) {\n    throw new Error(`QOA file size must be >= ${QOA_MIN_FILESIZE}`);\n  }\n\n  const stream = new BitInputStream(data);\n  const audio = decodeHeader(stream);\n\n  const channelData = [];\n  const lmses = [];\n  for (let c = 0; c < audio.channels; c++) {\n    const d = new Float32Array(audio.samples);\n    channelData.push(d);\n    lmses.push(LMS());\n  }\n\n  let sampleIndex = 0;\n  let frameLen = 0;\n  do {\n    frameLen = qoa_decode_frame(stream, audio, lmses, channelData, sampleIndex);\n    sampleIndex += frameLen;\n  } while (frameLen && sampleIndex < audio.samples);\n\n  return {\n    ...audio,\n    channelData,\n  };\n}\n","import { BitOutputStream } from \"@thi.ng/bitstream\";\nimport {\n  qoa_lms_predict,\n  qoa_lms_update,\n  qoa_clamp,\n  qoa_dequant_tab,\n  qoa_scalefactor_tab,\n  LMS,\n  QOA_SLICE_LEN,\n  QOA_FRAME_LEN,\n  QOA_MAGIC,\n  QOA_LMS_LEN,\n  QOA_FRAME_SIZE,\n} from \"./lib/common.js\";\n\n/* The reciprocal_tab maps each of the 16 scalefactors to their rounded \nreciprocals 1/scalefactor. This allows us to calculate the scaled residuals in \nthe encoder with just one multiplication instead of an expensive division. We \ndo this in .16 fixed point with integers, instead of floats.\n\nThe reciprocal_tab is computed as:\nreciprocal_tab[s] <- ((1<<16) + scalefactor_tab[s] - 1) / scalefactor_tab[s] */\n\nconst qoa_reciprocal_tab = qoa_scalefactor_tab.map((s) =>\n  Math.floor(((1 << 16) + s - 1) / s)\n);\n\n/* The quant_tab provides an index into the dequant_tab for residuals in the\nrange of -8 .. 8. It maps this range to just 3bits and becommes less accurate at \nthe higher end. Note that the residual zero is identical to the lowest positive \nvalue. This is mostly fine, since the qoa_div() function always rounds away \nfrom zero. */\n\nconst qoa_quant_tab = [\n  // -8..-1\n  7, 7, 7, 5, 5, 3, 3, 1,\n  // 0\n  0,\n  //  1.. 8\n  0, 2, 2, 4, 4, 6, 6, 6,\n];\n\n/* qoa_div() implements a rounding division, but avoids rounding to zero for \nsmall numbers. E.g. 0.1 will be rounded to 1. Note that 0 itself still \nreturns as 0, which is handled in the qoa_quant_tab[].\nqoa_div() takes an index into the .16 fixed point qoa_reciprocal_tab as an\nargument, so it can do the division with a cheaper integer multiplication. */\n\nfunction qoa_div(v, scalefactor) {\n  const reciprocal = qoa_reciprocal_tab[scalefactor];\n  let n = (v * reciprocal + (1 << 15)) >> 16;\n  n = n + ((v > 0) - (v < 0)) - ((n > 0) - (n < 0)); /* round away from 0 */\n  return n;\n}\n\nfunction qoa_encode_frame(stream, audio, lmses, sample_offset, frame_len) {\n  const channels = audio.channels;\n  const sampleRate = audio.sampleRate;\n  const channelData = audio.channelData;\n  const samples = audio.samples;\n\n  const slices = Math.floor((frame_len + QOA_SLICE_LEN - 1) / QOA_SLICE_LEN);\n  const frame_size = QOA_FRAME_SIZE(channels, slices);\n\n  // Frame header\n  stream.write(channels, 8);\n  stream.write(sampleRate, 24);\n  stream.write(frame_len, 16); // frame samples\n  stream.write(frame_size, 16);\n\n  // write current LMS weights and history state\n  for (let c = 0; c < channels; c++) {\n    const lms = lmses[c];\n\n    /* If the weights have grown too large, reset them to 0. This may happen\n\t\twith certain high-frequency sounds. This is a last resort and will \n\t\tintroduce quite a bit of noise, but should at least prevent pops/clicks */\n    const weights_sum =\n      lms.weights[0] * lms.weights[0] +\n      lms.weights[1] * lms.weights[1] +\n      lms.weights[2] * lms.weights[2] +\n      lms.weights[3] * lms.weights[3];\n    if (weights_sum > 0x2fffffff) {\n      lms.weights[0] = 0;\n      lms.weights[1] = 0;\n      lms.weights[2] = 0;\n      lms.weights[3] = 0;\n    }\n\n    for (let i = 0; i < QOA_LMS_LEN; i++) {\n      stream.write(lms.history[i], 16);\n    }\n    for (let i = 0; i < QOA_LMS_LEN; i++) {\n      stream.write(lms.weights[i], 16);\n    }\n  }\n\n  /* We encode all samples with the channels interleaved on a slice level.\n\tE.g. for stereo: (ch-0, slice 0), (ch 1, slice 0), (ch 0, slice 1), ...*/\n  for (\n    let sample_index = 0;\n    sample_index < frame_len;\n    sample_index += QOA_SLICE_LEN\n  ) {\n    for (let c = 0; c < channels; c++) {\n      const slice_len = qoa_clamp(QOA_SLICE_LEN, 0, frame_len - sample_index);\n      const slice_start = sample_index;\n\n      /* Brute for search for the best scalefactor. Just go through all\n\t\t\t16 scalefactors, encode all samples for the current slice and \n\t\t\tmeassure the total squared error. */\n      let best_error = Number.MAX_SAFE_INTEGER;\n      let best_slice;\n      let best_slice_scalefactor;\n      let best_lms;\n      const sampleData = channelData[c];\n\n      for (let scalefactor = 0; scalefactor < 16; scalefactor++) {\n        /* We have to reset the LMS state to the last known good one\n\t\t\t\tbefore trying each scalefactor, as each pass updates the LMS\n\t\t\t\tstate when encoding. */\n        let lms = LMS(lmses[c].history, lmses[c].weights);\n\n        const table = qoa_dequant_tab[scalefactor];\n\n        // an array of slice data\n        let slice = [];\n        let current_error = 0;\n        let idx = slice_start + sample_offset;\n\n        for (let i = 0; i < slice_len; i++) {\n          let sample = sampleData[idx++];\n\n          // turn into 16 bit signed integer\n          sample = Math.floor(\n            Math.fround(sample < 0 ? sample * 32768 : sample * 32767)\n          );\n          sample = qoa_clamp(sample, -32768, 32767);\n\n          let predicted = qoa_lms_predict(lms.weights, lms.history);\n          let residual = sample - predicted;\n          let scaled = qoa_div(residual, scalefactor);\n          let clamped = qoa_clamp(scaled, -8, 8);\n          let quantized = qoa_quant_tab[clamped + 8];\n          let dequantized = table[quantized];\n          let reconstructed = qoa_clamp(predicted + dequantized, -32768, 32767);\n          let error = sample - reconstructed;\n          current_error += error * error;\n          if (current_error > best_error) {\n            break;\n          }\n\n          qoa_lms_update(lms.weights, lms.history, reconstructed, dequantized);\n          slice.push(quantized);\n        }\n\n        if (current_error < best_error) {\n          best_error = current_error;\n          best_slice = slice;\n          best_slice_scalefactor = scalefactor;\n          best_lms = lms;\n        }\n      }\n\n      lmses[c] = best_lms;\n      // first, write the 4bit scalefactor\n      stream.write(best_slice_scalefactor, 4);\n      // now write each 3bit datum in the slice\n      for (let i = 0; i < QOA_SLICE_LEN; i++) {\n        // the last frame of a file might be smaller than QOA_SLICE_LEN\n        const v = i < best_slice.length ? best_slice[i] : 0;\n        stream.write(v, 3);\n      }\n    }\n  }\n}\n\nexport default function encode({ channelData, sampleRate = 44100 } = {}) {\n  const channels = channelData.length;\n  const samples = channels >= 1 ? channelData[0].length : 0;\n  const audio = {\n    samples,\n    channels,\n    channelData,\n    sampleRate,\n  };\n\n  const num_frames = (samples + QOA_FRAME_LEN - 1) / QOA_FRAME_LEN;\n  const num_slices = (samples + QOA_SLICE_LEN - 1) / QOA_SLICE_LEN;\n  const encoded_size =\n    8 /* 8 byte file header */ +\n    num_frames * 8 /* 8 byte frame headers */ +\n    num_frames *\n      QOA_LMS_LEN *\n      4 *\n      audio.channels /* 4 * 4 bytes lms state per channel */ +\n    num_slices * 8 * audio.channels; /* 8 byte slices */\n\n  const lmses = [];\n  for (let c = 0; c < audio.channels; c++) {\n    const lms = LMS();\n    lms.weights[0] = 0;\n    lms.weights[1] = 0;\n    lms.weights[2] = -(1 << 13);\n    lms.weights[3] = 1 << 14;\n    lmses.push(lms);\n  }\n\n  // write header\n  const stream = new BitOutputStream(encoded_size);\n  stream.write(QOA_MAGIC, 32);\n  stream.write(samples, 32);\n\n  let frame_len = QOA_FRAME_LEN;\n  for (\n    let sample_index = 0;\n    sample_index < samples;\n    sample_index += frame_len\n  ) {\n    frame_len = qoa_clamp(QOA_FRAME_LEN, 0, samples - sample_index);\n    qoa_encode_frame(stream, audio, lmses, sample_index, frame_len);\n  }\n\n  return stream.bytes();\n}\n"],"names":["defError","prefix","suffix","msg","__publicField","IllegalArgumentError","illegalArgs","IllegalStateError","illegalState","U32","BitInputStream","buffer","offset","limit","j","i","b","pos","wordSize","safe","out","n","msb","fields","word","acc","id","l","requested","QOA_MIN_FILESIZE","QOA_SLICE_LEN","QOA_LMS_LEN","QOA_MAGIC","qoa_clamp","v","min","max","LMS","h","w","history","weights","qoa_lms_predict","qoa_lms_update","sample","residual","delta","qoa_round","num","qoa_scalefactor_tab","_","s","dqt","qoa_dequant_tab","sf","dq","decodeHeader","stream","header","qoa_decode_frame","audio","lmses","channelData","sampleOffset","channels","sampleRate","samples","frameSize","dataSize","maxTotalSamples","c","lms","sample_index","scalefactor","table","slice_start","slice_count","sampleData","idx","bitsRemaining","predicted","quantized","dequantized","reconstructed","decode","data","d","sampleIndex","frameLen"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6]}